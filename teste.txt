async salvarPedido(session: Stripe.Checkout.Session) {
  const clienteId = Number(session.metadata?.clienteId);
  if (!clienteId) throw new Error("ClienteId ausente");

  const cliente = await this.prisma.cliente.findUnique({ where: { id: clienteId } });
  if (!cliente) throw new Error("Cliente nÃ£o encontrado");

  const pedidoExistente = await this.prisma.pedido.findUnique({ where: { stripeSessionId: session.id } });
  if (pedidoExistente) return; // evita duplicidade

  const numeroPedido = String(Math.floor(Math.random() * 9000000 + 1000000));
  let itemsMetadata: CheckoutItemDto[] = JSON.parse(session.metadata?.items || "[]");

  await this.prisma.$transaction(async (tx) => {
    const itensToCreate = [];

    for (const item of itemsMetadata) {
      const produto = await tx.produto.findUnique({ where: { id: item.produtoId } });
      if (!produto) throw new Error(`Produto ID ${item.produtoId} nÃ£o encontrado`);
      if (produto.estoque < item.quantidade) throw new Error(`Estoque insuficiente`);

      await tx.produto.update({
        where: { id: produto.id },
        data: { estoque: produto.estoque - item.quantidade },
      });

      itensToCreate.push({
        produtoId: produto.id,
        quantidade: item.quantidade,
        valor: produto.price * item.quantidade,
      });
    }

    await tx.pedido.create({
      data: {
        numeroPedido,
        clienteId,
        valorTotal: (session.amount_total ?? 0) / 100,
        status: "PAGO",
        stripeSessionId: session.id,
        itens: { create: itensToCreate },
      },
    });
  });
}



async salvarPedido(session: Stripe.Checkout.Session) {
    this.logger.log(`Processando pedido da sessÃ£o: ${session.id}`);

    const clienteId = Number(session.metadata?.clienteId);
    if (!clienteId) {
      this.logger.error("ClienteId ausente na sessÃ£o Stripe");
      return;
    }

    const cliente = await this.prisma.cliente.findUnique({
      where: { id: clienteId },
    });
    if (!cliente) {
      this.logger.error(`Cliente nÃ£o encontrado ID: ${clienteId}`);
      return;
    }

    // ðŸš¨ evita salvar pedido duplicado em caso de reenvio do webhook
    const pedidoExistente = await this.prisma.pedido.findUnique({
      where: { stripeSessionId: session.id },
    });
    console.log("Pedido existente:", pedidoExistente);

    if (pedidoExistente) {
      this.logger.warn(`Pedido jÃ¡ processado para sessÃ£o: ${session.id}`);
      return;
    }

    const numeroPedido = String(Math.floor(Math.random() * 9000000 + 1000000));
    let itemsMetadata: CheckoutItemDto[] = [];

    try {
      itemsMetadata = JSON.parse(session.metadata?.items || "[]");
    } catch (e) {
      this.logger.error("Erro ao converter metadata.items:", e);
      return;
    }

    this.logger.log("ðŸŽ¯ Webhook recebido, iniciando criaÃ§Ã£o do pedido...");

    // Calcula soma dos itens para validaÃ§Ã£o
    const totalItens = itemsMetadata.reduce(
      (acc, item) => acc + item.preco * item.quantidade,
      0
    );
    const valorTotalPedido = (session.amount_total ?? 0) / 100;

    if (Math.abs(totalItens - valorTotalPedido) > 0.01) {
      this.logger.error(
        `Soma dos itens (${totalItens.toFixed(
          2
        )}) difere do valor total do pedido (${valorTotalPedido.toFixed(2)})`
      );
      throw new Error(
        `Soma dos itens (${totalItens.toFixed(
          2
        )}) diferente do valor total do pedido (${valorTotalPedido.toFixed(2)})`
      );
    }

    await this.prisma.$transaction(async (tx) => {
      this.logger.debug(
        `ðŸ“‘ Items Metadata: ${JSON.stringify(itemsMetadata, null, 2)}`
      );

      const itensToCreate: {
        produtoId: number;
        quantidade: number;
        valor: number;
      }[] = [];

      for (const item of itemsMetadata) {
        const produto = await tx.produto.findUnique({
          where: { id: item.produtoId },
        });

        if (!produto) {
          throw new Error(`Produto ID ${item.produtoId} nÃ£o encontrado`);
        }

        if (produto.estoque < item.quantidade) {
          throw new Error(`Estoque insuficiente para ${produto.title}`);
        }

        // Atualiza estoque
        await tx.produto.update({
          where: { id: produto.id },
          data: { estoque: produto.estoque - item.quantidade },
        });

        itensToCreate.push({
          produtoId: produto.id,
          quantidade: item.quantidade,
          valor: produto.price * item.quantidade,
        });
      }

      // Cria o pedido com os itens
      const pedido = await tx.pedido.create({
        data: {
          numeroPedido,
          clienteId: cliente.id,
          valorTotal: valorTotalPedido,
          status: "PAGO",
          stripeSessionId: session.id,
          itens: { create: itensToCreate },
        },
      });

      this.logger.log(`ðŸ“¦ Pedido ${pedido.numeroPedido} salvo com sucesso.`);
    });